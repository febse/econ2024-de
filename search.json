[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Einführung in die Ökonometrie",
    "section": "",
    "text": "Setup\nIn den Übungen werden wir die Programmiersprache Python verwenden, um die in der Vorlesung behandelten Themen zu erklären und an realen Daten zu üben. Die Übungen werden in Form von Jupyter Notebooks bereitgestellt, die Sie in Ihrer eigenen Umgebung ausführen können.\nDeswegen ist es notwendig, zuerst eine Arbeitsumgebung einzurichten.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "index.html#git",
    "href": "index.html#git",
    "title": "Einführung in die Ökonometrie",
    "section": "Git",
    "text": "Git\nDie Übungen werden in einem Git-Repository auf GitHub bereitgestellt. Git ist ein Versionskontrollsystem, das die Änderungen an Dateien verfolgt und es ermöglicht, verschiedene Versionen von Dateien zu speichern. GitHub ist eine Plattform, die auf Git basiert und es ermöglicht, Git-Repositories zu hosten und zu teilen.\nWir werden Git verwenden, um die Übungen herunterzuladen und um Ihre Lösungen hochzuladen.\nInstallieren Sie Git von https://git-scm.com/downloads. Wählen Sie die Version, die zu Ihrem Betriebssystem passt und folgen Sie den Anweisungen. Lassen Sie die Standardeinstellungen unverändert, es sei denn, Sie wissen ganz genau, was Sie tun.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "index.html#github-account",
    "href": "index.html#github-account",
    "title": "Einführung in die Ökonometrie",
    "section": "GitHub Account",
    "text": "GitHub Account\nFür die Übungen brauchen Sie ein GitHub.com Konto:\n\nErstellen Sie ein Konto auf https://github.com/signup.\nBei der Registrierung wählen Sie ein Passwort, das Sie nirgendwo anders verwenden. Am Ende des Semesters können Sie Ihr Passwort ändern.\nEmpfehlung: Aktivieren Sie die Zwei-Faktor-Authentifizierung (2FA) in den Einstellungen Ihres GitHub-Kontos.\nEmpfehlung: Beantragen Sie die Studentenvorteile, um kostenlosen Zugang zu GitHub Copilot zu erhalten, einem KI-gestützten Code-Completion- und Chat-Tool.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "index.html#visual-studio-code",
    "href": "index.html#visual-studio-code",
    "title": "Einführung in die Ökonometrie",
    "section": "Visual Studio Code",
    "text": "Visual Studio Code\nVisual Studio Code (VSC) ist ein Open-Source-Code-Editor, den wir für die Arbeit mit Python benutzen werden.\nInstallieren Sie Visual Studio Code von https://code.visualstudio.com/. Wählen Sie die Version, die zu Ihrem Betriebssystem passt und folgen Sie den Anweisungen.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "index.html#kursrepository-klonen",
    "href": "index.html#kursrepository-klonen",
    "title": "Einführung in die Ökonometrie",
    "section": "Kursrepository klonen",
    "text": "Kursrepository klonen\nÖffnen Sie VSC und drücken Sie Ctrl+Shift+P. Suchen Sie nach “Git: Clone” und drücken Sie Enter. Geben Sie die URL des Kursrepositories ein:\nhttp://github.com/febse/econ2024-de.git\nWählen Sie einen Ordner auf Ihrem Computer, in dem Sie das Repository speichern möchten. VSC wird das Repository herunterladen und fragen, ob Sie es öffnen möchten. Klicken Sie auf “Open”.\nWarten Sie einen Moment, bis VSC das Repository geöffnet hat. Sie sollten eine Ordnerstruktur sehen, die den Inhalt des Repositories darstellt. VSC wird Sie fragen, ob Sie die empfohlenen Erweiterungen installieren möchten. Klicken Sie auf “Install All”.\nAm Ende sollten Sie die folgenden Erweiterungen installiert haben:\n\nms-python.autopep8\nms-python.python\nms-python.debugpy\nms-vscode-remote.remote-containers\nms-toolsai.jupyter\ngithub.codespaces\ngithub.copilot\n\nDrucken Sie Ctrl+Shift+X. Dieses wird die Erweiterungsansicht öffnen. Überprüfen Sie ob alle Erweiterungen installiert sind. Falls nicht, kopieren Sie die Kennzeichen (z.B. ms-python.autopep8) der fehlenden Erweiterungen von der Liste (oben), finden Sie die Erweiterungen in der Erweiterungsansicht und installieren Sie sie manuell.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "index.html#python",
    "href": "index.html#python",
    "title": "Einführung in die Ökonometrie",
    "section": "Python",
    "text": "Python\nPython ist zurzeit eine der meistbenutzten Programmiersprachen in der Welt. Es ist einfach zu lernen und hat eine große Community, die viele Bibliotheken und Frameworks entwickelt hat. In der Welt der Datenwissenschaft werden meistens Python und R benutzt. In den letzten Jahren stieg die Popularität von Python.\n\nCodespaces (empfohlen)\nUm die Konfiguration zu vereinfachen, können Sie Codespaces benutzen. In den ersten Übungen werden wir eine Anleitung zeigen, wie Sie Codespaces benutzen können.\n\n\nMiniconda\nEs gibt viele Möglichkeiten, wie Sie Python local auf Ihrem Rechner installieren können. Hier zeigen wir die Installation mit Miniconda. Conda ist ein Paketmanager, der es ermöglicht, Python-Umgebungen zu verwalten. Eine Python-Umgebung ist eine isolierte Instanz von Python, die es ermöglicht, verschiedene Versionen von Python und verschiedenen Bibliotheken zu verwenden, ohne dass sie sich gegenseitig beeinflussen. Das ist vor allem dann nützlich, wenn Sie an verschiedenen Projekten arbeiten, die unterschiedliche Anforderungen an Python und Bibliotheken haben.\n\nLaden Sie das Miniconda Installationspaket von https://docs.conda.io/en/latest/miniconda.html für Ihr Betriebssystem.\nStarten Sie das Packet und folgen Sie den Anweisungen. Lassen Sie die Standardeinstellungen unverändert, es sei denn, Sie wissen was Sie tun.\nInstallieren Sie Conda in einem Ordner ohne Leerzeichen und nur mit ASCII Zeichen im Pfad (d.h. keine Kyrillischen Zeichen, keine Umlaute, etc.), z.B. C:\\Miniconda3 oder C:\\Users\\boyko\\Miniconda3.\nNachdem Miniconda installiert ist, öffnen Sie VSC. Drücken Sie Ctrl+Shift+P und starten Sie zu schreiben: “Python: Create environment”. Wenn die Option in dem Dropdown-Menü erscheint, wählen Sie sie und drucken Sie Enter.\nWählen Sie “Conda”.\nWählen Sie die Python-3.11 Version.\nDieses wird einen Order namens .conda erstellen.\nFalls Sie diese Schritte in dem Order des Kursrepositories gemacht haben, werden dann automatisch die notwendingen Bibliotheken installiert.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "index.html#pycharm-optional",
    "href": "index.html#pycharm-optional",
    "title": "Einführung in die Ökonometrie",
    "section": "Pycharm (optional)",
    "text": "Pycharm (optional)\nStatt VSC können Sie auch PyCharm oder DataSpell benutzen. PyCharm ist eine integrierte Entwicklungsumgebung (IDE) für Python, die von JetBrains entwickelt wurde. PyCharm ist eine der beliebtesten Python-IDEs und bietet viele Funktionen, die die Entwicklung von Python-Programmen erleichtern. Falls Sie mit PyCharm oder DataSpell experimentieren möchten, bieten wir für die Übungen kostenfreie Lizenzen an.\n\nRegistrieren Sie sich auf https://account.jetbrains.com/signup mit Ihrer Universitäts-E-Mail-Adresse (muss auf feb.uni-sofia.bg oder feba.uni-sofia.bg enden).\nLaden Sie Pycharm von https://www.jetbrains.com/pycharm/download/ herunter und installieren Sie es.\nBeim Aktivierungsdialog wählen Sie “Licence Server” und geben Sie https://febs.fls.jetbrains.com/ ein.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "01-Python/01-01-Basics.html",
    "href": "01-Python/01-01-Basics.html",
    "title": "1  Python Basics",
    "section": "",
    "text": "1.0.1 Jupyter Notebooks in VS Code\nHäufig verwendete Tastenkombinationen\nShortcuts für den Kommando-Modus (Edit Mode)\nShortcuts für den Edit Modus - Alt + Shift + ↑: Die aktuelle Zeile nach oben kopieren (Fokus bleibt auf der aktuellen Zeile) - Alt + Shift + ↓: Die aktuelle Zeile nach unten kopieren (Fokus verlagert sich zur nächsten Zeile) - Ctrl+Enter/Shift+Enter: Markierte Zelle ausführen und Fokus auf die nächste Zelle setzen\nShortcuts für beide Modi",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "01-Python/01-01-Basics.html#klassen-und-objekte",
    "href": "01-Python/01-01-Basics.html#klassen-und-objekte",
    "title": "1  Python Basics",
    "section": "5.1 Klassen und Objekte",
    "text": "5.1 Klassen und Objekte\nBisher haben wir verschiedene Datentypen gesehen, drei verschiedene Datenstrukturen (Listen, Tupel und Dictionaries) und Funktionen gesehen. In Python gibt es auch Objekte, die Daten und Funktionen zusammenbinden. Funktionen, die zu einem Objeckt gehören, nennen wir Methoden. Diese Objekte können wir mit Klassen erstellen. Klassen sind wie Baupläne für Objekte.\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def introduce_yourself(self):\n        print(\"Hi, my name is\", self.name, \"and I am\", self.age, \"years old.\")\n\n\nivan = Person(\"Ivan\", 20)\n\nprint(ivan.name)\nprint(ivan.age)\n\nIvan\n20\n\n\n\nivan.introduce_yourself()\n\nHi, my name is Ivan and I am 20 years old.\n\n\n\n5.1.1 Lambdafunktionen\nManchmal möchten wir eine Funktion nur einmal verwenden. Dafür können wir Lambda Funktionen verwenden. Diese Funktionen haben keinen Namen. Wir können sie mit dem Schlüsselwort lambda erstellen. Die Argumente der Funktion werden durch ein Komma getrennt hinter dem Schlüsselwort lambda geschrieben. Der Rückgabewert der Funktion wird nach einem Doppelpunkt geschrieben.\nZum Beispiel können wir eine Lambdafunktion verwenden, um den Stromverbrauch in BGN zu berechnen.\n\nstromverbrauch_bgn = map(lambda x: x * 1.955, stromverbrauch)",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "01-Python/01-02-Basics-Ex.html",
    "href": "01-Python/01-02-Basics-Ex.html",
    "title": "2  Übung: Python Basics",
    "section": "",
    "text": "2.0.1 Aufgabe 1\n\nBerechnen Sie die Summe der Zahlen 32.8 und 45.1\nBerechnen Sie die Differenz der Zahlen 32.8 und 45.1\nSpeichern Sie die Zahl 32.8 in a und die Zahl 45.1 in b. Berechnen Sie das Verhältnis von a zu b und speichern Sie das Ergebnis in c.\n\n\n\n2.0.2 Aufgabe 2\nErstellen Sie eine Liste mit den Zahlen 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 und speichern Sie diese in der Variable numbers. - Geben Sie die Liste aus (mit print()) - Geben Sie das erste Element der Liste aus - Geben Sie das letzte Element der Liste aus - Geben Sie das dritte Element der Liste aus - Geben Sie das dritte und das siebte Element der Liste aus - Ersetzen Sie das vierte Element der Liste durch die Zahl 42\n\n\n2.0.3 Aufgabe 3\nErstellen Sie zwei Listen names und ages mit den folgenden Elementen: - names: “Alice”, “Bob”, “Charlie”, “Dave”, “Eve” - ages: 17, 42, 30, 37, 21\n\nGeben Sie die Liste names aus\nSchreiben Sie eine for-Schleife, die die Namen und das Alter der Personen ausdruckt. Die Ausgabe soll folgendermaßen aussehen: “Alice ist 23 Jahre alt”\nSie möchten nur die Namen der Personen ausdrucken, die älter als 30 Jahre sind. Schreiben Sie eine for-Schleife, die das tut.\nSie möchten eine neue Liste erstellen, die nur die Namen der Personen enthält, die älter als 30 Jahre sind. Schreiben Sie eine Listenabstraktion, die das tut.\n\n\n\n2.0.4 Aufgabe 4\nIn dieser Aufgabe werden wir eine Funktion is_in_list schreiben, die einen Namen als Argument annimmt und True oder False zurückgibt, falls der Name einer Person entspricht, die in der Liste names aus Aufgabe 3 enthalten ist.\n\n\n2.0.5 Aufgabe 5\nIn dieser Aufgabe werden wir eine Funktion get_age schreiben, die einen Namen als Argument annimmt und das Alter der Person zurückgibt, falls der Name einer Person entspricht, die in der Liste names aus Aufgabe 3 enthalten ist. Falls der Name nicht in der Liste enthalten ist, soll die Funktion None zurückgeben.\n\n\n2.0.6 Aufgabe 6\nIn dieser Aufgabe werden wir eine Funktion is_eligible schreiben, die True, False oder None zurückgibt, je nachdem ob eine Person wahlberechtigt ist oder nicht. Die Funktion soll einen Namen als Argument annehmen und das Alter der Person zurückgeben, falls der Name einer Person entspricht, die in der Liste names aus Aufgabe 3 enthalten ist. Falls der Name nicht in der Liste enthalten ist, soll die Funktion None zurückgeben. Falls der Name in der Liste enthalten ist, soll die Funktion True zurückgeben, falls die Person älter als 18 Jahre ist, andernfalls soll die Funktion False zurückgeben.\n\n\n2.0.7 Aufgabe 7\nIn dieser Aufgabe werden wir ein Dictionary erstellen, das die Namen aus Aufgabe 3 als Schlüssel und die Alter aus Aufgabe 3 als Werte enthält. Speichern Sie das Dictionary in der Variable persons.\n\nBenutzen Sie das Dictionary, um das Alter von Bob auszudrucken.\nÄndern Sie das Alter von Alice auf 43 Jahre.\nFügen Sie eine neue Person “Frank” mit dem Alter 33 Jahre hinzu.\nSchreiben Sie eine for-Schleife, die die Namen und das Alter der Personen ausdruckt. Die Ausgabe soll folgendermaßen aussehen: “Alice ist 23 Jahre alt”\nSie möchten nur die Namen der Personen ausdrucken, die mit “A” anfangen. Schreiben Sie eine for-Schleife, die über persons iteriert und das tut.",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Übung: Python Basics</span>"
    ]
  },
  {
    "objectID": "01-Python/01-03-Numpy.html",
    "href": "01-Python/01-03-Numpy.html",
    "title": "3  NumPy",
    "section": "",
    "text": "In der vorherigen Lektion haben wir uns mit Listen beschäftigt. Diese sind sehr flexibel, aber auch sehr langsam. Mit kleinen Listen werden wir das nicht merken, aber wenn wir mit großen Datenmengen arbeiten, dann кönnen lange Laufzeiten zum Problem werden.\nNumPy (Numerical Python) ist ein Paket, das viele Funktionen enthält, die wir für die Arbeit mit großen Datenmengen geeignet sind.\n\nimport numpy as np\nfrom time import process_time\n\n\n# Wir können eine Liste in ein NumPy-Array umwandeln\npython_list = range(int(1e6))\nnumpy_array = np.array(python_list)\n\n\nstart_zeit = process_time()\n\na_list_plus_2 = [i + 2 for i in python_list]\n\nend_zeit = process_time()\nround(end_zeit - start_zeit, 5)\n\n0.03513\n\n\n\nstart_zeit_1 = process_time()\n\na_array_plus_2 = numpy_array + 2\n\nend_zeit_1 = process_time()\nround(end_zeit_1 - start_zeit_1, 5)\n\n0.00217\n\n\n\nx = np.array([2, 7, 5, 2])\ny = np.ones(4)\ny\n\narray([1., 1., 1., 1.])\n\n\nNumPy-Arrays sind sehr ähnlich zu Listen, aber sie haben einige zusätzliche Eigenschaften. Zum Beispiel können wir mit NumPy-Arrays rechnen. Wenn wir zwei NumPy-Arrays addieren, dann werden die Elemente an der gleichen Stelle addiert. Diese Syntax ist sehr intuitiv und einfach zu lesen.\n\nz1 = x + 1 \nz2 = x + y\nz1\n\narray([3, 8, 6, 3])\n\n\n\nz2\n\narray([3., 8., 6., 3.])\n\n\nDasselbe funktioniert mit Python-Listen nicht. Wenn wir zwei Listen addieren, dann werden die Elemente an der gleichen Stelle nicht addiert, sondern die Listen werden aneinander gehängt.\n\nx_list = [2, 7, 5, 2]\ny_list = [1, 1, 1, 1]\nx_plus_y_list = x_list + y_list\nx_plus_y_list\n\n[2, 7, 5, 2, 1, 1, 1, 1]\n\n\n\n# x_list + 1\n\nNumPy-Arrays haben auch einige Methoden, die wir mit Listen nicht haben. Zum Beispiel können wir die Summe aller Elemente eines Arrays berechnen.\n\n# Summe der Elemente\nx.sum()\n\n16\n\n\n\n# Durchschnitt der Elemente (Arithmetischer Mittelwert)\n\nx.mean()\n\n4.0\n\n\n\n# Standardabweichung\nx.std()\n\n2.1213203435596424\n\n\n\n# Minimum\nx.min()\n\n2\n\n\n\n# Maximum\nx.max()\n\n7\n\n\n\n# Der Index des Minimums\nx.argmin()\n\n0\n\n\n\n# Der Index des Maximums\nx.argmax()\n\n1\n\n\n\n3.0.1 Slicing\nWir können auch auf die Elemente eines Arrays zugreifen, indem wir einen Index angeben. Der Index beginnt bei 0.\n\nz = np.array([\"a\", \"b\", \"c\", \"d\", \"e\"])\n\n\n# Das erste Element\nz[0]\n\n'a'\n\n\n\n# Alle Elemente bis zur Indexposition 2 (exklusive)\n# Achten Sie darauf, dass der Index 0-basiert ist und daher das dritte Element ist eine Indexposition 2 hat\nz[:2]\n\narray(['a', 'b'], dtype='&lt;U1')\n\n\n\nz[-3]\n\n'c'\n\n\n\nz[-3:]\n\narray(['c', 'd', 'e'], dtype='&lt;U1')\n\n\n\nz[1:3]\n\narray(['b', 'c'], dtype='&lt;U1')\n\n\n\nz[::2]\n\narray(['a', 'c', 'e'], dtype='&lt;U1')\n\n\n\nz[::-1]\n\narray(['e', 'd', 'c', 'b', 'a'], dtype='&lt;U1')\n\n\n\n\n3.0.2 Arrays und Listen Zuweisung\nEine zugängige Erläuterung, wie Werte im Speicher des Rechners gespeichert werden, finden Sie in hier.\n\nz[1] = \"x\"\nz\n\narray(['a', 'x', 'c', 'd', 'e'], dtype='&lt;U1')\n\n\n\nz1 = z\n\n\nz[0] = \"X\"\n\n\nz1\n\narray(['X', 'x', 'c', 'd', 'e'], dtype='&lt;U1')\n\n\n\nz1 == z\n\narray([ True,  True,  True,  True,  True])\n\n\n\nprint(id(z1))\nprint(id(z))\n\n140074503717680\n140074503717680\n\n\n\nl1 = [1, 2, 3]\nl2 = l1\n\nprint(id(l1))\nprint(id(l2))\n\n140075665847168\n140075665847168\n\n\n\ns1 = \"Some string\"\ns2 = s1\n\nprint(id(s1))\nprint(id(s2))\n\n# s1[0] = \"X\"\n\n140075665643120\n140075665643120",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html",
    "href": "01-Python/01-04-Pandas.html",
    "title": "4  Pandas",
    "section": "",
    "text": "4.1 Series\nDie einfachste Datenstruktur in Pandas ist die Series. Eine Series ist eine eindimensionale Datenstruktur, die mit einem NumPy-Array vergleichbar ist. Eine Series kann mit der Funktion pd.Series() erstellt werden. Als Argument wird ein Array übergeben. Die Series hat einen Index, der standardmäßig mit 0 beginnt. Der Index kann mit dem Argument index angepasst werden. Der Index kann ein Array von Strings sein, um die Elemente der Series zu benennen.\n# Erstellen einer Series\ns = pd.Series([1, 2, 3, 4, 5])\ns\n\n0    1\n1    2\n2    3\n3    4\n4    5\ndtype: int64\n# Erstellen einer Series mit Index\ns1 = pd.Series([1, 2, 3, 4, 5], index=['a', 'b', 'c', 'd', 'e'])\ns1\n\na    1\nb    2\nc    3\nd    4\ne    5\ndtype: int64\nDie Series hat eine Reihe von Methoden, die aufgerufen werden können. Eine Übersicht über die Methoden kann mit help(pd.Series) aufgerufen werden. Die wichtigsten Methoden sind:\n# Zugriff auf den Index\ns1.index\n\nIndex(['a', 'b', 'c', 'd', 'e'], dtype='object')\n# Zugriff auf die Werte\ns1.values\n\narray([1, 2, 3, 4, 5])\n# Zugriff auf ein Element\ns1['a']\n\n1\n# Zugriff auf mehrere Elemente\ns1[['a', 'c', 'e']]\n\na    1\nc    3\ne    5\ndtype: int64\n# Zugriff auf ein Element mit dem Ganzzahl-Index\ns1.iloc[0]\n\n1\n# Zugriff auf mehrere Elemente mit dem Index\ns1.loc[\"a\"]\n\n1\ns1.loc[[\"a\", \"c\", \"e\"]]\n\na    1\nc    3\ne    5\ndtype: int64\ns1.sum()\n\n15\ns1.mean()\n\n3.0\ns1.std()\n\n1.5811388300841898",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html#dataframe",
    "href": "01-Python/01-04-Pandas.html#dataframe",
    "title": "4  Pandas",
    "section": "4.2 DataFrame",
    "text": "4.2 DataFrame\nDas wichtigste Datenobjekt in Pandas ist der DataFrame. Ein DataFrame ist eine zweidimensionale Datenstruktur, die mit einer Tabelle vergleichbar ist. Ein DataFrame kann mit der Funktion pd.DataFrame() erstellt werden. Als Argument wird ein Array übergeben. Der DataFrame hat einen Index, der standardmäßig mit 0 beginnt. Der Index kann mit dem Argument index angepasst werden. Der Index kann ein Array von Strings sein, um die Zeilen des DataFrame zu benennen. Die Spalten des DataFrame können mit dem Argument columns benannt werden.\n\ndf = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 7, 9], [10, 11, 12]], columns=['A', 'B', 'C'])\ndf\n\n\n\n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n0\n1\n2\n3\n\n\n1\n4\n5\n6\n\n\n2\n7\n7\n9\n\n\n3\n10\n11\n12\n\n\n\n\n\n\n\n\n\ndf1 = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 7, 9], [10, 11, 12]],\n                   index=['a', 'b', 'c', 'd'],\n                   columns=['X', 'Y', 'Z']\n                   )\ndf1\n\n\n\n\n\n\n\n\n\nX\nY\nZ\n\n\n\n\na\n1\n2\n3\n\n\nb\n4\n5\n6\n\n\nc\n7\n7\n9\n\n\nd\n10\n11\n12\n\n\n\n\n\n\n\n\nDie DataFrame hat eine Reihe von Methoden, die aufgerufen werden können. Eine Übersicht über die Methoden kann mit help(pd.DataFrame) aufgerufen werden. Die wichtigsten Methoden sind:\n\ndf1[\"X\"].sum()\n\n22\n\n\n\ndf1[\"X\"].mean()\n\n5.5\n\n\n\ndf1[\"X\"].std()\n\n3.872983346207417\n\n\n\ndf1[\"X\"].describe()\n\ncount     4.000000\nmean      5.500000\nstd       3.872983\nmin       1.000000\n25%       3.250000\n50%       5.500000\n75%       7.750000\nmax      10.000000\nName: X, dtype: float64",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html#axes",
    "href": "01-Python/01-04-Pandas.html#axes",
    "title": "4  Pandas",
    "section": "4.3 Axes",
    "text": "4.3 Axes\nDie axes eines DataFrame sind die Zeilen und Spalten des DataFrame. Die Zeilen können mit df.index und die Spalten mit df.columns abgerufen werden. Die Eigenschaft (property) shape gibt die Anzahl der Zeilen und Spalten des DataFrame zurück.\n\ndf1.shape\n\n(4, 3)\n\n\nViele Methoden können auf die Zeilen und Spalten des DataFrame angewendet werden.\n\ndf1\n\n\n\n\n\n\n\n\n\nX\nY\nZ\n\n\n\n\na\n1\n2\n3\n\n\nb\n4\n5\n6\n\n\nc\n7\n7\n9\n\n\nd\n10\n11\n12\n\n\n\n\n\n\n\n\n\ndf1.mean(axis=0)\n\nX    5.50\nY    6.25\nZ    7.50\ndtype: float64\n\n\n\ndf1.mean(axis=1)\n\na     2.000000\nb     5.000000\nc     7.666667\nd    11.000000\ndtype: float64\n\n\n\ndf1.mean()\n\nX    5.50\nY    6.25\nZ    7.50\ndtype: float64",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html#neue-spalte-hinzufügen",
    "href": "01-Python/01-04-Pandas.html#neue-spalte-hinzufügen",
    "title": "4  Pandas",
    "section": "4.4 Neue Spalte hinzufügen",
    "text": "4.4 Neue Spalte hinzufügen\nEine neue Spalte kann zu einem DataFrame hinzugefügt werden, indem ein neues Array als Wert der neuen Spalte zugewiesen wird. Die neue Spalte wird automatisch an das Ende des DataFrame hinzugefügt.\n\ndf1[\"New\"] = [1, 2, 3, 4]\ndf1.head()\n\n\n\n\n\n\n\n\n\nX\nY\nZ\nNew\n\n\n\n\na\n1\n2\n3\n1\n\n\nb\n4\n5\n6\n2\n\n\nc\n7\n7\n9\n3\n\n\nd\n10\n11\n12\n4\n\n\n\n\n\n\n\n\nHäufig wird eine neue Spalte aus bestehenden Spalten berechnet. Dazu können die bestehenden Spalten wie normale Arrays verwendet werden. Die neue Spalte wird automatisch an das Ende des DataFrame hinzugefügt.\n\ndf1[\"X_min_Y\"] = df1[\"X\"] - df1[\"Y\"]\ndf1.head()\n\n\n\n\n\n\n\n\n\nX\nY\nZ\nNew\nX_min_Y\n\n\n\n\na\n1\n2\n3\n1\n-1\n\n\nb\n4\n5\n6\n2\n-1\n\n\nc\n7\n7\n9\n3\n0\n\n\nd\n10\n11\n12\n4\n-1\n\n\n\n\n\n\n\n\n\ndf1[\"X_2\"] = 2 *df1[\"X\"]\ndf1.head()\n\n\n\n\n\n\n\n\n\nX\nY\nZ\nNew\nX_min_Y\nX_2\n\n\n\n\na\n1\n2\n3\n1\n-1\n2\n\n\nb\n4\n5\n6\n2\n-1\n8\n\n\nc\n7\n7\n9\n3\n0\n14\n\n\nd\n10\n11\n12\n4\n-1\n20",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html#selektieren-von-zeilen",
    "href": "01-Python/01-04-Pandas.html#selektieren-von-zeilen",
    "title": "4  Pandas",
    "section": "4.5 Selektieren von Zeilen",
    "text": "4.5 Selektieren von Zeilen\nHäufig möchten wir nur eine Teilmenge der Zeilen eines DataFrame selektieren, z.B. die ersten 5 Zeilen oder die Zeilen, die eine bestimmte Bedingung erfüllen (z.B. Männer/Frauen, beschäftigt/arbeitslos, etc.).\n\n# Als Beispiel wählen wir die ersten drei Zeilen\n\ndf1.iloc[0:2]\n\n\n\n\n\n\n\n\n\nX\nY\nZ\nNew\nX_min_Y\nX_2\n\n\n\n\na\n1\n2\n3\n1\n-1\n2\n\n\nb\n4\n5\n6\n2\n-1\n8\n\n\n\n\n\n\n\n\n\n# Als anderes Beispiel wählen wir die Zeilen, für die X größer als 3 ist\n\ndf1[df1[\"X\"] &gt; 3]\n\n\n\n\n\n\n\n\n\nX\nY\nZ\nNew\nX_min_Y\nX_2\n\n\n\n\nb\n4\n5\n6\n2\n-1\n8\n\n\nc\n7\n7\n9\n3\n0\n14\n\n\nd\n10\n11\n12\n4\n-1\n20",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html#selektieren-von-spalten",
    "href": "01-Python/01-04-Pandas.html#selektieren-von-spalten",
    "title": "4  Pandas",
    "section": "4.6 Selektieren von Spalten",
    "text": "4.6 Selektieren von Spalten\nHäufig möchten wir nur eine Teilmenge der Spalten eines DataFrame selektieren, z.B. die Spalten, die für eine bestimmte Analyse relevant sind.\n\ndf1[[\"X\", \"Y\"]]\n\n\n\n\n\n\n\n\n\nX\nY\n\n\n\n\na\n1\n2\n\n\nb\n4\n5\n\n\nc\n7\n7\n\n\nd\n10\n11",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html#groupby",
    "href": "01-Python/01-04-Pandas.html#groupby",
    "title": "4  Pandas",
    "section": "4.7 GroupBy",
    "text": "4.7 GroupBy\nMit der Funktion groupby() können die Daten in einem DataFrame gruppiert werden. Die Funktion groupby() gibt ein DataFrameGroupBy-Objekt zurück. Mit diesem Objekt können verschiedene Aggregationsfunktionen aufgerufen werden. Die wichtigsten Aggregationsfunktionen sind: - count(): Anzahl der Elemente - sum(): Summe der Elemente - mean(): Mittelwert der Elemente - median(): Median der Elemente - min(): Minimum der Elemente - max(): Maximum der Elemente - std(): Standardabweichung der Elemente - var(): Varianz der Elemente - describe(): Statistische Kennzahlen der Elemente - first(): Erstes Element - last(): Letztes Element - nth(): n-tes Element\n\ndf2 = pd.DataFrame({\n    \"Name\": [\"Alice\", \"Bob\", \"Mallory\", \"Mallory\", \"Bob\", \"Mallory\"],\n    \"Gender\": [\"f\", \"m\", \"f\", \"f\", \"m\", \"f\"],\n    \"YearOfBirth\": [1999, 1985, 1997, 1990, 1987, 1990],\n}\n)\ndf2[\"Age\"] = 2024 - df2[\"YearOfBirth\"]\ndf2.head()\n\n\n\n\n\n\n\n\n\nName\nGender\nYearOfBirth\nAge\n\n\n\n\n0\nAlice\nf\n1999\n25\n\n\n1\nBob\nm\n1985\n39\n\n\n2\nMallory\nf\n1997\n27\n\n\n3\nMallory\nf\n1990\n34\n\n\n4\nBob\nm\n1987\n37\n\n\n\n\n\n\n\n\n\ndf2_by_gender = df2.groupby(\"Gender\")\ndf2_by_gender\n\n&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x7f5674bd0cd0&gt;\n\n\n\ndf2_by_gender[\"Age\"].mean()\n\nGender\nf    30.0\nm    38.0\nName: Age, dtype: float64",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-05-Pandas-Ex.html",
    "href": "01-Python/01-05-Pandas-Ex.html",
    "title": "5  Übung zu Pandas",
    "section": "",
    "text": "Für den Zweck der Buchhaltung in einem Unternehmen soll ein DataFrame erstellt werden, welches die folgenden Spalten enthält:\n\nPosition: Die Position im Unternehmen\nArbeitszeit: Die Arbeitszeit pro Woche\nLohn: Der wöchentliche Lohn in Euro\n\nDie Werte für die Position sollen aus der folgenden Liste entnommen werden:\nPosition: ['CEO', 'CFO', 'CTO', 'CIO', 'COO', 'CDO', 'CMO', 'CRO', 'CSO', 'CPO']\nArbeitszeit: [40, 40, 20, 40, 20, 40, 10, 40, 40, 60]\nGehalt: [10000, 8500, 2000, 3022, 1039, 2500, 3000, 1800, 20000, 10000]\n\n6 Aufgabe 1\n\nNennen Sie den DataFrame df und geben Sie ihn aus.\nGeben Sie die Spalte Position aus.\nGeben Sie die ersten 3 Zeilen des DataFrames aus.\nGeben Sie die letzten 3 Zeilen des DataFrames aus.\nGeben Sie die ersten 3 Zeilen der Spalte Position aus.\nGeben Sie die letzten 3 Zeilen der Spalte Position aus.\nGeben Sie die ersten 3 Zeilen der Spalten Position und Gehalt aus.\n\n\n\n7 Aufgabe 2\n\nBerechnen Sie den durchschnittlichen Gehalt im Unternehmen.\nBerechnen Sie den Stundenlohn für jede Personen im Unternehmen.\nBerechnen Sie den durchschnittlichen Stundenlohn im Unternehmen.\nBerechnen Sie den durchschnittlichen Stundenlohn für jede Position im Unternehmen.\nFinden Sie den niedrigsten Stundenlohn im Unternehmen.\nFinden Sie die Position mit dem niedrigsten Stundenlohn im Unternehmen.\nFinden Sie den höchsten Stundenlohn im Unternehmen.",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Übung zu Pandas</span>"
    ]
  },
  {
    "objectID": "02-Review/01-Descriptive-Statistics.html",
    "href": "02-Review/01-Descriptive-Statistics.html",
    "title": "6  Deskriptive Statistik mit Pandas",
    "section": "",
    "text": "6.1 Streuung\nDer Mittelwert informiert uns über das Zentrum (Lage) der Daten. Die zweite Charakteristik einer Variable, die wir verstehen wollen, ist wie weit die Daten verteilt sind (wie unterschiedlich, heterogen, die Kunden in Bezug auf die Größe sind, zum Beispiel). Der Begriff der Streuung ist abstrakt und kann auf verschiedene Weisen gemessen werden. Wir können uns die Streuung zum Beispiel als die durchschnittliche Differenz der Kunden zum Mittelwert vorstellen. Dies ist das Konzept der Varianz.\n# Now let's calculate the variance using pandas\n\ncustomers[\"height\"][0:3].var()\n\n28.0\n# When using numpy, note that you will get a different result\n\nnp.var(customers[\"height\"][0:3])\n\n18.666666666666668\nThe reason for this is by default numpy uses the so called population (or uncorrected) variance, which is defined as:\nS^2 = \\frac{1}{n} \\sum_{i=1}^{n} (x_i - \\bar{x})^2\nThe only difference is the denominator, which is n instead of n-1. To get the sample variance, we need to set the parameter ddof (denominator degrees of freedom) to 1.\nnp.var(customers[\"height\"][0:3], ddof=1)\n\n28.0\n# Now the standard deviation\n\ncustomers[\"height\"][0:3].std()\n\n5.291502622129181\nnp.std(customers[\"height\"][0:3], ddof=1)\n\n5.291502622129181",
    "crumbs": [
      "Statistik Überblick",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Deskriptive Statistik mit Pandas</span>"
    ]
  },
  {
    "objectID": "02-Review/01-Descriptive-Statistics.html#streuung",
    "href": "02-Review/01-Descriptive-Statistics.html#streuung",
    "title": "6  Deskriptive Statistik mit Pandas",
    "section": "",
    "text": "Definition 6.2 (Sample Variance and Sample Standard Deviation) Für eine Variable x mit n Beobachtungen: x_1, x_2, \\ldots, x_n, ist die Stichprobenvarianz definiert als:\n\nS^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (x_i - \\bar{x})^2\n\nDabei ist \\bar{x} der Stichprobenmittelwert.\nDie Stichprobenstandardabweichung ist die Quadratwurzel der Stichprobenvarianz:\n\nS = \\sqrt{S^2}\n\n\n\nBeispiel 6.2 (Sample Variance and Sample Standard Deviation) Lasst uns die Stichprobenstandardabweichung für die ersten drei Besucher berechnen x_1 = 74, x_2 = 66, x_3 = 64.\nZuerst müssen wir den Stichprobenmittelwert ausrechnen: \\bar{x} = 68 (Beispiel 6.1)\nDanach berechnen wir die Differenzen der Werte zum Mittelwert und quadrieren diese:\n\nS^2 = \\frac{(74 - 68)^2 + (66 - 68)^2 + (64 - 68)^2}{3-1} = \\frac{36 + 4 + 16}{2} = 28\n\nDie Stichprobenstandardabweichung ist die Quadratwurzel der Stichprobenvarianz:\n\nS = \\sqrt{28} \\approx 5.29",
    "crumbs": [
      "Statistik Überblick",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Deskriptive Statistik mit Pandas</span>"
    ]
  },
  {
    "objectID": "02-Review/01-Descriptive-Statistics.html#weitere-maße-der-lage-und-streuung",
    "href": "02-Review/01-Descriptive-Statistics.html#weitere-maße-der-lage-und-streuung",
    "title": "6  Deskriptive Statistik mit Pandas",
    "section": "6.2 Weitere Maße der Lage und Streuung",
    "text": "6.2 Weitere Maße der Lage und Streuung\nDie Reduzierung auf einen einzigen Wert als Stichprobenmittelwert ist sehr nützlich, weil wir leicht darüber nachdenken können (nur ein Wert). Allerdings ignoriert diese Reduktion viele Details über die Kunden. Zum Beispiel wissen wir nicht, wie viele Kunden nahe am Mittelwert sind, wie viele weit entfernt sind, und so weiter. Die Standardabweichung hilft uns, dies zu verstehen, ist aber immer noch eine einzige Zahl.\nUm unser Verständnis der Daten weiter zu vertiefen, können wir andere Maße der Lage und Streuung verwenden.\n\nDer Median ist der Wert, der die Daten in zwei gleiche Hälften teilt. Es ist der Wert, der die gleiche Anzahl von Beobachtungen über und unter sich hat. Sie können sagen, dass etwa die Hälfte der Beobachtungen einen Wert kleiner als den Median hat und etwa die andere Hälfte einen Wert größer als den Median hat. Ein anderer Name für den Median ist das zweite Quartil (Q2). Dies kommt daher, dass die Stichprobe in vier Teile geteilt wird. Ein weiterer Name für den Median ist das 50. Perzentil (Teilung der Stichprobe in 100 Teile) oder das 0,5-Quantil.\nDas erste Quartil (Q1) ist der Wert, der die ersten 25% der Daten von den restlichen trennt. Sie können sagen, dass ungefähr 25% der Beobachtungen einen Wert kleiner als Q1 und 75% einen Wert größer als Q1 haben. Ein anderer Name für das erste Quartil ist das 25. Perzentil oder das 0,25-Quantil.\nDas zweite Quartil (Q2) ist der Median.\nDas dritte Quartil (Q3) ist der Wert, der die ersten 75% der Daten von den restlichen trennt. Sie können sagen, dass ungefähr 75% der Beobachtungen einen Wert kleiner als Q3 und 25% einen Wert größer als Q3 haben. Ein anderer Name für das dritte Quartil ist das 75. Perzentil oder das 0,75-Quantil.\nDas Maximum ist der größte Wert in den Daten. Es wird manchmal das 100. Perzentil genannt.\nDas Minimum ist der kleinste Wert in den Daten. Es wird manchmal das 0. Perzentil genannt.\n\nDie Differenz zwischen dem Minimum und dem Maximum ist der Bereich (range) der Daten. Es ist ein Maß für die Streuung der Daten, aber es ist sehr anfällig für extreme Werte. Ein Ausreißer ist ein Wert, der sehr weit von den anderen Werten entfernt ist. Der Median und die Quartile sind weniger anfällig für Ausreißer und werden als robuste Maße der Lage und Streuung bezeichnet.\nDie Differenz zwischen dem dritten und dem ersten Quartil ist der Interquartilsabstand (IQR). Es ist ein Maß für die Streuung der mittleren 50% der Daten. Es ist auch ein robustes Maß der Streuung, da es weniger anfällig für Ausreißer ist.\n\n# Let's calculate the median, Q1, and Q3 using pandas. It also outputs the minimum and maximum values as well as the count of non-missing values\n# and the number of unique values\n\ncustomers[\"height\"].describe()\n\ncount    1816.000000\nmean       66.568833\nstd         3.831822\nmin        57.000000\n25%        64.000000\n50%        66.000000\n75%        69.250000\nmax        82.000000\nName: height, dtype: float64\n\n\n\nprint(customers[\"height\"].min())\nprint(customers[\"height\"].quantile(0.25))\nprint(customers[\"height\"].quantile(0.5))\nprint(customers[\"height\"].quantile(0.75))\nprint(customers[\"height\"].max())\n\n57\n64.0\n66.0\n69.25\n82\n\n\n\ncustomers[\"height\"].quantile(0.75) - customers[\"height\"].quantile(0.25)\n\n5.25\n\n\nBerechnen Sie den Mittelwert, Median, Standardabweichung, Minimum, Maximum, Quartile und Interquartilsabstand für das Gewicht der Kunden.\n\n# Schreiben Sie Ihren Code hier",
    "crumbs": [
      "Statistik Überblick",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Deskriptive Statistik mit Pandas</span>"
    ]
  },
  {
    "objectID": "02-Review/01-Descriptive-Statistics.html#zusammenfassung-kategorischer-variablen",
    "href": "02-Review/01-Descriptive-Statistics.html#zusammenfassung-kategorischer-variablen",
    "title": "6  Deskriptive Statistik mit Pandas",
    "section": "6.3 Zusammenfassung kategorischer Variablen",
    "text": "6.3 Zusammenfassung kategorischer Variablen\nDer Mittelwert und die Standardabweichung machen nur für Variablen Sinn, für die Addition und Multiplikation sinnvoll sind. Insbesondere machen sie keinen Sinn für kategoriale Variablen, z. B. die Ethnie der Kunden.\nDie wichtigste Zusammenfassung für kategoriale Variablen ist die Häufigkeitstabelle. Eine Häufigkeitstabelle zeigt die Anzahl der Beobachtungen für jede Kategorie. Die relative Häufigkeitstabelle zeigt den Anteil der Beobachtungen für jede Kategorie.\n\ncustomers[\"ethnicity\"].value_counts()\n\nethnicity\nWhite       1494\nBlack        180\nHispanic     104\nOther         38\nName: count, dtype: int64",
    "crumbs": [
      "Statistik Überblick",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Deskriptive Statistik mit Pandas</span>"
    ]
  },
  {
    "objectID": "02-Review/01-Descriptive-Statistics.html#datentransformationen",
    "href": "02-Review/01-Descriptive-Statistics.html#datentransformationen",
    "title": "6  Deskriptive Statistik mit Pandas",
    "section": "6.4 Datentransformationen",
    "text": "6.4 Datentransformationen\nEs ist in fast jeder Analyse notwendig, die Daten zu transformieren. Als Beispiel können wir die Größe in Inch in Zentimeter umrechnen. Die Umrechnung von Inch in Zentimeter erfolgt durch Multiplikation mit 2,54. Die Umrechnung von Pfund in Kilogramm erfolgt durch Multiplikation mit 0,45.\n\ncustomers[\"height_cm\"] = customers[\"height\"] * 2.54\n\n\n# Erstellen Sie eine neue Spalte \"weight_kg\" in dem Dataframe \"customers\", die die Werte der Spalte \"weight\" in Kilogramm umrechnet.\n# 1 Pfund entspricht 0.453592 Kilogramm.\n\nHäufige möchten wir eine stetiige Variable in Kategorien einteilen. Zum Beispiel möchten wir eine Variable erstellen, die angibt, ob eine Person jünger als 30 Jahre ist oder nicht. Dies ist eine binäre Variable, die wir aus einer kontinuierlichen Variable erstellen.\n\ncustomers[\"is_under_30\"] = customers[\"age\"] &lt; 30\ncustomers[\"is_under_30\"].head()\n\n0    False\n1    False\n2     True\n3    False\n4    False\nName: is_under_30, dtype: bool\n\n\nFalls wir mehr als zwei Kategorien brauchen, bietet die Funktion pd.cut die Möglichkeit, die Daten in Kategorien einzuteilen.\n\ncustomers[\"age_group\"] = pd.cut(\n    customers[\"age\"],\n    bins=[0, 30, 64, np.inf],\n    labels=[\"&lt;30\", \"30-64\", \"65+\"]\n)\n\ncustomers[[\"age\", \"age_group\"]].head()\n\n\n\n\n\n\n\n\n\nage\nage_group\n\n\n\n\n0\n45\n30-64\n\n\n1\n58\n30-64\n\n\n2\n29\n&lt;30\n\n\n3\n57\n30-64\n\n\n4\n91\n65+",
    "crumbs": [
      "Statistik Überblick",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Deskriptive Statistik mit Pandas</span>"
    ]
  },
  {
    "objectID": "02-Review/01-Descriptive-Statistics.html#aufgabe",
    "href": "02-Review/01-Descriptive-Statistics.html#aufgabe",
    "title": "6  Deskriptive Statistik mit Pandas",
    "section": "6.5 Aufgabe",
    "text": "6.5 Aufgabe\nBerechnen Sie den BMI (Body Mass Index) für die Kunden. Der BMI ist definiert als das Körpergewicht in Kilogramm geteilt durch das Quadrat der Größe in Metern. Das Gewicht muss in Kilogramm und die Größe in Metern sein. Danach berechnen Sie den mittleren BMI. Die Referenzwerte für den BMI sind:\n\nUnter 18,5: Untergewicht\n18,5 - 24,9: Normalgewicht\n25 - 29,9: Übergewicht\n30 oder mehr: Adipositas\nEin Verkäufer behauptet, daß die Kunden in dem Einkaufszentrum im Durchschnitt übergewichtig sind. Überprüfen Sie diese Behauptung anhand der Daten.\nEin anderer Verkäufer behauptet, daß mehr als ein Viertel der Besucher im Einkaufszentrum adipös sind. Überprüfen Sie diese Behauptung anhand der Daten.\n\nTeilen Sie die Kunden in die folgenden Kategorien ein: - Untergewicht - Normalgewicht - Übergewicht - Adipositas\nZählen Sie die Anzahl der Kunden in jeder Kategorie.\n\n6.5.1 Graphical Summaries\nAlthough the numeric summaries are very useful, a visual representation of the data can be extremely powerful, because the human brain is very good at picking up visual patterns. The most common graphical summaries are histograms, kernel density plots and boxplots.\n\nA histogram is a bar plot that shows the frequency of the data in different intervals. It is a way to visualize the distribution of the data. The visualization depends on how we group values together in intervals (bins). Setting the value for the bins too high will make the histogram very noisy, because it will effectively plot every single observation. Setting the value for the bins too low will make the histogram too smooth, because it will group too many observations together. The default value for the bins is 10. In practice you should try different values to see which one gives you the best visualization. It should highlight features of the data that you are interested in.\n\n\nsns.histplot(customers[\"height\"], bins=18)\n\n/usr/share/miniconda/envs/econ2024/lib/python3.11/site-packages/seaborn/_oldcore.py:1119: FutureWarning:\n\nuse_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n\n\n\n\n\n\n\n\n\n\nAnother way to visualize the distribution of the data is the kernel density plot. It is a smoothed version of the histogram. Instead of using bins to group the data, the kernel density plot uses a kernel to estimate the probability density function of the data. This topic is beyond the scope of this course, but it is important to know that the kernel density plot is a smoothed version of the histogram.\n\nsns.kdeplot(customers[\"height\"], shade=True)\n\n/tmp/ipykernel_2243/696753787.py:1: FutureWarning:\n\n\n\n`shade` is now deprecated in favor of `fill`; setting `fill=True`.\nThis will become an error in seaborn v0.14.0; please update your code.\n\n\n/usr/share/miniconda/envs/econ2024/lib/python3.11/site-packages/seaborn/_oldcore.py:1119: FutureWarning:\n\nuse_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n\n\n\n\n\n\n\n\n\n\n\n\n6.5.2 Boxplot\nThe boxplot was created as a way to easily spot unusual observations in the data. It is a graphical representation of the quantiles of the data. The boxplot is a way to visualize the median, the quartiles.\n\nsns.boxplot(customers[\"height\"])\n\n\n\n\n\n\n\n\nThe boxplot is very useful when comparing the distributions of different groups. For example, let’s say that we want to compare the annual income of the customers by their gender.\n\ncustomers[\"sex\"] = pd.Categorical(customers[\"male\"], categories=[0, 1], ordered=False)\n\nSometimes the picture becomes hard to read if there are extreme values if the data. In the previous example there are a few customers with very high annual income. This stretches the x-axis and obscures the boxplot. One way to deal with this is to zoom in on the center of the data by setting the limits of the x-axis.\n\n#\nsns.boxplot(x=\"earnk\", y=\"sex\", data=customers)\n\n/usr/share/miniconda/envs/econ2024/lib/python3.11/site-packages/seaborn/categorical.py:641: FutureWarning:\n\nThe default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n\n\n\n\n\n\n\n\n\n\n#\nax = sns.boxplot(x=\"earnk\", y=\"sex\", data=customers)\nax.set_xlim((0, 75))\n\n/usr/share/miniconda/envs/econ2024/lib/python3.11/site-packages/seaborn/categorical.py:641: FutureWarning:\n\nThe default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n\n\n\n\n\n\n\n\n\n\n\n6.5.3 Bivariate Data\nThe previous summaries are useful when we want to understand a single variable. However, we often want to understand the relationship between two variables. For example, we might want to understand the relationship between the height and weight of the customers. We will take this example, because we already have a lot of experience with the height (because of daily life) (XXX, w).\nThe most basic and most important tool for understanding the relationship between two variables is the scatter plot. This is a plot where each point represents a pair of values of the two variables. For example, the first point in the scatter plot of height and weight represents the height and weight of the first customer. The second point represents the height and weight of the second customer, and so on.\n\nsns.scatterplot(x=\"height\", y=\"weight\", data=customers)\n\n\n\n\n\n\n\n\nWhen we have a lot of data points, the scatter plot can become very hard to read, because the points overlap (this is called overplotting). One way to deal with this is to use make the points smaller and transparent so that we can focus on the overall pattern of the data. When there is a lot of rounding in the data (the height is rounded to the nearest inch in our example) we will see a lot of points in the same location. This is the reason we are seeing vertical lines in the scatter plot above. One way to deal with this is to add a little bit of random noise to the data. This is called jittering.\n\nsns.stripplot(\n    x=\"height\",\n    y=\"weight\",\n    data=customers,\n    jitter=0.5,\n    alpha=0.3,\n    size=4\n)\n\n/usr/share/miniconda/envs/econ2024/lib/python3.11/site-packages/seaborn/_oldcore.py:1119: FutureWarning:\n\nuse_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n\n/usr/share/miniconda/envs/econ2024/lib/python3.11/site-packages/seaborn/_oldcore.py:1119: FutureWarning:\n\nuse_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n\n/usr/share/miniconda/envs/econ2024/lib/python3.11/site-packages/seaborn/_oldcore.py:1075: FutureWarning:\n\nWhen grouping with a length-1 list-like, you will need to pass a length-1 tuple to get_group in a future version of pandas. Pass `(name,)` instead of `name` to silence this warning.\n\n\n\n\n\n\n\n\n\n\n\nimport plotly.express as px\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\n\npx.scatter(\n    customers,\n    x=\"height\",\n    y=\"weight\"\n)\n\n\n\n                                                \n\n\nAbbildung 6.1: GDP and Life Expectancy",
    "crumbs": [
      "Statistik Überblick",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Deskriptive Statistik mit Pandas</span>"
    ]
  },
  {
    "objectID": "06-Interactions/kids.html",
    "href": "06-Interactions/kids.html",
    "title": "7  OLS Regression Results",
    "section": "",
    "text": "import pandas as pd\n\nkids = pd.read_csv(\"https://github.com/febse/data/raw/main/econ/childiq.csv\")\n\nkids.head()\n\n\n\n\n\n\n\n\n\nkid_score\nmom_hs\nmom_iq\nmom_work\nmom_age\n\n\n\n\n0\n65\n1\n121.117529\n4\n27\n\n\n1\n98\n1\n89.361882\n4\n25\n\n\n2\n85\n1\n115.443165\n4\n27\n\n\n3\n83\n1\n99.449639\n3\n25\n\n\n4\n115\n1\n92.745710\n4\n27\n\n\n\n\n\n\n\n\n\nimport statsmodels.formula.api as smf\n\nmodel = smf.ols(\"kid_score ~ mom_hs * mom_iq\", data=kids)\nresults = model.fit()\nprint(results.summary())\n\nDep. Variable:              kid_score   R-squared:                       0.230\nModel:                            OLS   Adj. R-squared:                  0.225\nMethod:                 Least Squares   F-statistic:                     42.84\nDate:                Wed, 06 Mar 2024   Prob (F-statistic):           3.07e-24\nTime:                        15:55:37   Log-Likelihood:                -1867.5\nNo. Observations:                 434   AIC:                             3743.\nDf Residuals:                     430   BIC:                             3759.\nDf Model:                           3                                         \nCovariance Type:            nonrobust                                         \n=================================================================================\n                    coef    std err          t      P&gt;|t|      [0.025      0.975]\n---------------------------------------------------------------------------------\nIntercept       -11.4820     13.758     -0.835      0.404     -38.523      15.559\nmom_hs           51.2682     15.338      3.343      0.001      21.122      81.414\nmom_iq            0.9689      0.148      6.531      0.000       0.677       1.260\nmom_hs:mom_iq    -0.4843      0.162     -2.985      0.003      -0.803      -0.165\n==============================================================================\nOmnibus:                        8.014   Durbin-Watson:                   1.660\nProb(Omnibus):                  0.018   Jarque-Bera (JB):                8.258\nSkew:                          -0.333   Prob(JB):                       0.0161\nKurtosis:                       2.887   Cond. No.                     3.10e+03\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n[2] The condition number is large, 3.1e+03. This might indicate that there are\nstrong multicollinearity or other numerical problems.\n\n\n\nimport seaborn as sns\n\nsns.lmplot(x=\"mom_iq\", y=\"kid_score\", hue=\"mom_hs\", data=kids)",
    "crumbs": [
      "Das lineare Regressionsmodell",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>kids.html</span>"
    ]
  },
  {
    "objectID": "Literature.html",
    "href": "Literature.html",
    "title": "Literatur",
    "section": "",
    "text": "James u. a. (2023)\n\nDas Lehrbuch ist eine Einführung in die statistische Lerntheorie und behandelt das lineare Regressionsmodell, das der Kern des Kurses ist. Enthalten sind Beispielanwendungen in Python.\n\nMcKinney (2022)\n\nDas Buch ist eine Einführung in die Datenanalyse mit Python und behandelt die Grundlagen der Programmiersprache und der Datenanalyse. Es ist ein guter Einstieg in die Programmierung mit Python.\n\nGelman, Hill, und Vehtari (2021):\n\nRegression and other stories. Cambridge New York, NY Port Melbourne, VIC New Delhi Singapore: Cambridge University Press (Analytical methods for social research). Available at: https://doi.org/10.1017/9781139161879.\n\n\n\n\nGelman, Andrew, Jennifer Hill, und Aki Vehtari. 2021. Regression and Other Stories. Analytical Methods for Social Research. Cambridge New York, NY Port Melbourne, VIC New Delhi Singapore: Cambridge University Press. https://doi.org/10.1017/9781139161879.\n\n\nJames, Gareth, Daniela Witten, Trevor Hastie, Robert Tibshirani, und Jonathan Taylor. 2023. An Introduction to Statistical Learning with Applications in Python. Cham: Springer International Publishing.\n\n\nMcKinney, Wes. 2022. Python for Data Analysis: Data Wrangling with Pandas, NumPy, and Jupyter. Third edition. Beijing Boston Farnham Sebastopol Tokyo: O’Reilly.",
    "crumbs": [
      "Literatur"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Literaturverzeichnis",
    "section": "",
    "text": "Gelman, Andrew, Jennifer Hill, and Aki Vehtari. 2021. Regression and\nOther Stories. Analytical Methods for Social Research.\nCambridge New York, NY Port Melbourne, VIC New Delhi\nSingapore: Cambridge University Press. https://doi.org/10.1017/9781139161879.\n\n\nJames, Gareth, Daniela Witten, Trevor Hastie, Robert Tibshirani, and\nJonathan Taylor. 2023. An Introduction to\nStatistical Learning with Applications in\nPython. Cham: Springer\nInternational Publishing.\n\n\nMcKinney, Wes. 2022. Python for Data Analysis: Data Wrangling with\nPandas, NumPy, and Jupyter.\nThird edition. Beijing Boston Farnham Sebastopol Tokyo:\nO’Reilly.",
    "crumbs": [
      "Literaturverzeichnis"
    ]
  }
]